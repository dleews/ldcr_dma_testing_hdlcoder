// -------------------------------------------------------------
// 
// File Name: /home/draco/git/adi_dma_testing/iq_dma_example/hdl_ip/hdlsrc/rx_dma_test/rx_dma_test_src_LDCR_D.v
// Created: 2025-08-21 13:52:00
// 
// Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 3.25521e-08
// Target subsystem base rate: 3.25521e-08
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        3.25521e-08
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// AccumulatorCount              ce_out        3.25521e-08
// ch1_rx_dma_i                  ce_out        3.25521e-08
// ch1_rx_dma_q                  ce_out        3.25521e-08
// ch2_rx_dma_i                  ce_out        3.25521e-08
// ch2_rx_dma_q                  ce_out        3.25521e-08
// rx_dma_valid                  ce_out        3.25521e-08
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: rx_dma_test_src_LDCR_D
// Source Path: rx_dma_test/LDCR_D
// Hierarchy Level: 0
// Model version: 9.535
// 
// Simulink model description for rx_dma_test:
// 
// libiioSDRPSP_filter_example
// 
// A simple example model to demonstrate the use of MATLAB I/O alongside
// hardware/software co-design.
// 
// Implements AXI programmable gain and bypassable filters on the Tx and Rx
// paths of the HDL DUT.
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module rx_dma_test_src_LDCR_D
          (clk,
           reset,
           clk_enable,
           adc_data_i0,
           adc_valid_i0,
           adc_data_q0,
           adc_valid_q0,
           adc_data_i1,
           adc_valid_i1,
           adc_data_q1,
           adc_valid_q1,
           Accumulations,
           enable_rx_dma_count,
           ce_out,
           AccumulatorCount,
           ch1_rx_dma_i,
           ch1_rx_dma_q,
           ch2_rx_dma_i,
           ch2_rx_dma_q,
           rx_dma_valid);


  input   clk;
  input   reset;
  input   clk_enable;
  input   signed [15:0] adc_data_i0;  // int16
  input   adc_valid_i0;
  input   signed [15:0] adc_data_q0;  // int16
  input   adc_valid_q0;
  input   signed [15:0] adc_data_i1;  // int16
  input   adc_valid_i1;
  input   signed [15:0] adc_data_q1;  // int16
  input   adc_valid_q1;
  input   [31:0] Accumulations;  // uint32
  input   enable_rx_dma_count;
  output  ce_out;
  output  [31:0] AccumulatorCount;  // uint32
  output  [15:0] ch1_rx_dma_i;  // uint16
  output  [15:0] ch1_rx_dma_q;  // uint16
  output  [15:0] ch2_rx_dma_i;  // uint16
  output  [15:0] ch2_rx_dma_q;  // uint16
  output  rx_dma_valid;


  wire enb;
  reg signed [15:0] Data;  // int16
  wire signed [13:0] Cast4_out1;  // sfix14
  reg signed [15:0] Data_1;  // int16
  wire signed [13:0] Cast2_out1;  // sfix14
  reg  Valid;
  wire Channelizer_CH1_out2;
  wire Channelizer_CH1_out3;
  reg [31:0] Delay2_out1;  // uint32
  wire [31:0] Subsystem_out1;  // uint32
  wire [15:0] counter_subsystem_out1;  // uint16
  wire [15:0] counter_subsystem_out2;  // uint16
  wire [15:0] counter_subsystem_out3;  // uint16
  wire [15:0] counter_subsystem_out4;  // uint16

  // AXI4 Write Registers
  // ADC


  assign enb = clk_enable;

  always @(posedge clk)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Data <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Data <= adc_data_i0;
        end
      end
    end


  assign Cast4_out1 = Data[13:0];


  always @(posedge clk)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Data_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Data_1 <= adc_data_q0;
        end
      end
    end


  assign Cast2_out1 = Data_1[13:0];


  always @(posedge clk)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Valid <= 1'b0;
      end
      else begin
        if (enb) begin
          Valid <= adc_valid_i0;
        end
      end
    end


  rx_dma_test_src_Channelizer_CH1 u_Channelizer_CH1 (.clk(clk),
                                                     .reset(reset),
                                                     .enb(clk_enable),
                                                     .dataIn_re(Cast4_out1),  // sfix14
                                                     .dataIn_im(Cast2_out1),  // sfix14
                                                     .validIn(Valid),
                                                     .startOut(Channelizer_CH1_out2),
                                                     .endOut(Channelizer_CH1_out3)
                                                     );
  always @(posedge clk)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 32'b00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= Accumulations;
        end
      end
    end


  rx_dma_test_src_Subsystem u_Subsystem (.clk(clk),
                                         .reset(reset),
                                         .enb(clk_enable),
                                         .In1(Channelizer_CH1_out3),
                                         .enb_1(Channelizer_CH1_out2),
                                         .In3(Delay2_out1),  // uint32
                                         .count(Subsystem_out1)  // uint32
                                         );
  assign AccumulatorCount = Subsystem_out1;

  rx_dma_test_src_counter_subsystem u_counter_subsystem (.clk(clk),
                                                         .reset(reset),
                                                         .enb(clk_enable),
                                                         .enb_1(enable_rx_dma_count),
                                                         .ch1_re(counter_subsystem_out1),  // uint16
                                                         .ch1_im(counter_subsystem_out2),  // uint16
                                                         .ch2_re(counter_subsystem_out3),  // uint16
                                                         .ch2_im(counter_subsystem_out4)  // uint16
                                                         );
  assign ch1_rx_dma_i = counter_subsystem_out1;

  assign ch1_rx_dma_q = counter_subsystem_out2;

  assign ch2_rx_dma_i = counter_subsystem_out3;

  assign ch2_rx_dma_q = counter_subsystem_out4;

  assign rx_dma_valid = enable_rx_dma_count;

  assign ce_out = clk_enable;

endmodule  // rx_dma_test_src_LDCR_D

